---
title: 补码之特殊的10000000
date: 2024-10-30 11:37:57
tags:
---

## 时钟里的补数
现在指向6点，如果想到3点，逆时针拨动3格，顺时针拨动9格到，所以-3和9互为补数

## 补码的目的
计算机里存储的是补码，为了让计算机里存储的数，加减法使用同一套电路，也就是补码加减器，做减法时，+负数的补码，就将减法转换为了加法

所以补码有符号位
假设是8位补码系统，[00000000,01111111]是正数，[10000000,11111111]是负数
根据负数求补码的公式：x是真值，x<0, [x]补 = 256+x ====> x=[x]补-256,得到了根据补码求真值的**普遍方法**(**适用于任何补码**):
[-1]补=256+(-1)=255=11111111 ，-1 =补码11111111-256
[-127]补=256+(-127)=129=10000001，-127=补码10000001-256

特殊的-128来了
[-128]补=256+(-128)=128=10000000 ,-128=补码10000000-256,所以补码10000000的真值为-128

已知补码求真值，**一般方法**可以是：补码-1求得反码，反码求原码，再求真值
补码11111111，反码11111110，原码10000001，真值-1
补码10000001，反码10000000，原码11111110，真值-127

但是特殊的补码10000000呢？
补码10000000，反码01111111，原码10000000，真值-0 这个肯定是错误的，-0在计算机中以00000000的补码形式存储，与+0一样
其实这里开始就错了：
普遍方法中求得的真值永远是对的，所以补码为10000000=>符号位为1，所以是负数，所以按照公式[x]补 = 256+x求真值x,x=10000000-256=-10000000=-128
我们知道真值-128，不存在8位原码，8位反码，所以不能根据这种一般方法求

所以为了不出错，我们需要记住10000000这个特殊的机器数，不存在原码，反码，所以补码求原码这种算法不存在

这就是特殊的机器数，1……..,1后面n-1个0（假设机器字长为n位）